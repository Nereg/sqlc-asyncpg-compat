# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.25.0
# source: queries.sql
from typing import AsyncIterator
from typing import Optional

import sqlalchemy
import sqlalchemy.ext.asyncio
from sql import models

INSERT_ONE = """-- name: insert_one \\:exec
INSERT INTO sqlc_test(name, description) VALUES(:p1, :p2)
"""


SELECT_MANY = """-- name: select_many \\:many
SELECT name, description FROM sqlc_test
"""


SELECT_ONE = """-- name: select_one \\:one
SELECT name, description FROM sqlc_test WHERE name = :p1
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection) -> None:
        self._conn = conn

    async def insert_one(self, *, name: str, description: Optional[str]) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_ONE), {"p1": name, "p2": description})

    async def select_many(self) -> AsyncIterator[models.SqlcTest]:
        result = await self._conn.stream(sqlalchemy.text(SELECT_MANY))
        async for row in result:
            yield models.SqlcTest(
                name=row[0],
                description=row[1],
            )

    async def select_one(self, *, name: str) -> Optional[models.SqlcTest]:
        row = (await self._conn.execute(sqlalchemy.text(SELECT_ONE), {"p1": name})).first()
        if row is None:
            return None
        return models.SqlcTest(
            name=row[0],
            description=row[1],
        )
